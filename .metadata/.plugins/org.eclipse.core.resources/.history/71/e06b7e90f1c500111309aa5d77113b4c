package com.primitive2d;

import java.util.Set;
import java.util.Vector;

import processing.core.PApplet;
import processing.core.PConstants;

import com.datatype.DCFace;
import com.datatype.Point;
import com.math.Geom;

//base class for patterns and primitives
public class LineCollection extends DCFace implements Drawable, Turtle{
	
	private Vector<Line> lines;
	private Vector<Point> points; 
	private Vector<Polygon> polygons;
	private Vector<Ellipse> ellipses;
	
	public LineCollection(){
		this.lines = new Vector<Line>();
		this.points = new Vector<Point>(); 
		this.polygons = new Vector<Polygon>();
		this.ellipses = new Vector<Ellipse>();
		
		this.origin = new Point(0,0);

	}
	
	//sets a new origin for translations and rotations
	public void setOrigin(double x, double y){
	    	this.setOrigin(new Point(x,y));
	    }
	
	
	
	//=============================PRIMITIVE ADD METHODS==================================//
	
	//adds in a new point and automatically creates a new line if 1 or more points exist already
	public void addPoint(double x,double y){
		Point point = new Point(x,y);	
		this.addPoint(point);
	}
	
	public void addPoint(Point point){	
		points.add(point);
		//ensures there is never duplicate points in the list
		points= Geom.removeDuplicateVerts(points);
	}
	
	//adds a line in cart mode by specifying 4 coordinates
	public void addLine(double startX, double startY, double endX, double endY) {
		Line line = new Line(startX,startY,endX,endY);
		lines.add(line);
			
	}
	
	//adds a line in polar mode by specifying an origin, radius and angle
	public void addLine(Point origin, float radius, float theta) {
		Line line = new Line(origin,radius, theta);
		lines.add(line);
	}
	
	//adds a line by passing in a line
	public void addLine(Line line) {
		lines.add(line);
		this.addPoint(line.start);
		this.addPoint(line.end);
	}
	
	public void addPolygon(Polygon poly){
		this.polygons.add(poly);
		lines.addAll(poly.getAllLines());
		lines.addAll(poly.getAllLines());
		points.addAll(poly.getAllPoints());
		points= Geom.removeDuplicateVerts(points);

	}
	
	
	//=============================PRIMITIVE SET METHODS==================================//
	
	public void setAllPoints(Vector<Point> newPoints){
		this.points = newPoints ;
	}
	
	public void setPointAt(int index, Point newPoint){
		this.points.set(index, newPoint);
	}

	

	public void setAllLines(Vector<Line> newLines){
		this.lines = newLines ;
	}
	
	public void setLineAt(int index, Line newLine){
		this.lines.set(index, newLine);
	}

	
	//=============================PRIMITIVE GET METHODS==================================//
	
	public Vector<Point> getAllPoints(){
		return this.points;
	}

	public Point getPointAt(int index){
		return this.points.get(index);
	}
	
	public Vector<Line> getAllLines(){
		return this.lines;
	}

	public Line getLineAt(int index){
		return this.lines.get(index);
	}
	
	//=============================TRANFORM METHODS==================================//
	
	 //translates all lines to a new point;
    public void moveTo(double x, double y) {
        for (int i = 0; i < lines.size(); i++) {
            Line currentLine = lines.get(i);
            currentLine.moveTo(x, y,this.origin);
        }
        this.origin = new Point(x,y);
        
    }
    
    //translates all lines to a new point;
    @Override
    public void moveTo(double x, double y, Point focus) {
       for (int i = 0; i < lines.size(); i++) {
            Line currentLine = lines.get(i);
            currentLine.moveTo(x, y, focus);
        }
        
        
    }
    
	@Override
    public void moveBy(double x, double y) {
		 for (int i = 0; i < lines.size(); i++) {
	            Line currentLine = lines.get(i);
	            currentLine.moveBy(x, y);
	        }
        
    }
	
	@Override
	  //rotates all lines around the origin by an increment of theta;
    public void rotate(double theta) {
        this.rotate(theta,origin);
    }
	
	  //rotates all lines around the focus by an increment of theta;
    public void rotate(double theta, Point _focus) {
        for (int i = 0; i < lines.size(); i++) {
            Line currentLine = lines.get(i);
            currentLine.rotate(theta, _focus);
        }
    }
	
    
  //=============================DRAW AND PRINT METHODS==================================//
    
    public void draw(PApplet parent, float strokeWeight){
    	for(int i=0;i<points.size();i++){
    		//points.get(i).draw(parent, strokeWeight);
    		
    		
    	}
    	
    	for(int i=0;i<lines.size();i++){
    		lines.get(i).draw(parent, strokeWeight);
    		
    		
    	}
		
		
		for(int i=0;i<polygons.size();i++){
    		polygons.get(i).draw(parent, strokeWeight);
    		
    		
    	}
		
		for(int i=0;i<ellipses.size();i++){
    		//ellipses.get(i).draw(parent, strokeWeight);
    		
    		
    	}
	}
	
	public void print(PApplet parent, float strokeWeight, String filename){
		parent.beginRaw(PConstants.PDF, filename);
		this.draw(parent, strokeWeight);
		parent.endRaw();
		//TODO:implement print method

	}

	
 //=============================TURTLE METHODS==================================//

	@Override
	public void left(double angle) {
		TurtleStruct.angle-=angle;
		/*if(TurtleStruct.angle<0){
			TurtleStruct.angle = 360;
		}*/
		
	}

	@Override
	public void right(double angle) {
		// TODO Auto-generated method stub
		TurtleStruct.angle+=angle;
		/*if(TurtleStruct.angle>360){
			TurtleStruct.angle = 0;
		}*/
	}

	@Override
	public void forward(double dist) {
		Line newLine = new Line(TurtleStruct.location, dist, TurtleStruct.angle);
		if(TurtleStruct.pen){
			
			this.addLine(newLine);
		}
		TurtleStruct.location = newLine.end;
		
	}
	
	

	@Override
	public void back(double dist) {
		Line newLine = new Line(TurtleStruct.location, -dist, TurtleStruct.angle);
		if(TurtleStruct.pen){
			
			this.addLine(newLine);
		}
		TurtleStruct.location = newLine.end;
		
	}

	@Override
	public void penUp() {
		TurtleStruct.pen=false;
		// TODO Auto-generated method stub
		
	}

	@Override
	public void penDown() {
		TurtleStruct.pen=true;
		// TODO Auto-generated method stub
		
	}
	
	

	
}
